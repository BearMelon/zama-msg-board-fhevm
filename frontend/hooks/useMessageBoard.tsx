"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

/*
  The following two files are automatically generated by the script located at
  <root>/scripts/gen-messageboard-abi.mjs. This script parses the
  <root>/packages/fhevm-hardhat-template/deployments directory to retrieve
  deployment information for MessageBoard.sol:

  - <root>/packages/site/abi/MessageBoardABI.ts
  - <root>/packages/site/abi/MessageBoardAddresses.ts
*/
import { MessageBoardAddresses } from "@/abi/MessageBoardAddresses";
import { MessageBoardABI } from "@/abi/MessageBoardABI";

export type MessageType = {
  id: number;
  author: string;
  timestamp: number;
  title: string | undefined;
  content: string | undefined;
  isDecrypted: boolean;
};

type MessageBoardInfoType = {
  abi: typeof MessageBoardABI.abi;
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

/**
 * Resolves MessageBoard contract metadata for the given EVM `chainId`.
 *
 * The ABI and address book are **generated** from the `fhevm-hardhat-template`
 * artifacts into the `@/abi` folder at build time. This function performs a
 * simple lookup in that generated map.
 *
 * Behavior:
 * - If `chainId` is `undefined` or not found in the map, returns ABI only.
 * - Otherwise returns `{ abi, address, chainId, chainName }`.
 *
 * @param chainId - Target chain id (e.g., 1, 5, 11155111). `undefined` returns ABI-only.
 * @returns Contract info for the chain or ABI-only fallback.
 * @example
 * const { abi, address } = getMessageBoardByChainId(chainId);
 */
function getMessageBoardByChainId(
  chainId: number | undefined
): MessageBoardInfoType {
  if (!chainId) {
    return { abi: MessageBoardABI.abi };
  }

  const entry =
    MessageBoardAddresses[chainId.toString() as keyof typeof MessageBoardAddresses];

  if (!("address" in entry) || entry.address === ethers.ZeroAddress) {
    return { abi: MessageBoardABI.abi, chainId };
  }

  return {
    address: entry?.address as `0x${string}` | undefined,
    chainId: entry?.chainId ?? chainId,
    chainName: entry?.chainName,
    abi: MessageBoardABI.abi,
  };
}

/*
 * Main MessageBoard React component
 */
export const useMessageBoard = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  eip1193Provider: ethers.Eip1193Provider | undefined;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
  } = parameters;

  //////////////////////////////////////////////////////////////////////////////
  // States + Refs (refs are mostly used to access latest React values and avoid
  // state dependencies). Consider @tanstack/react-query as an alternative to
  // handle async operations like FHEVM encryption/decryption
  //////////////////////////////////////////////////////////////////////////////

  const [messages, setMessages] = useState<MessageType[]>([]);
  const [isRefreshing, setIsRefreshing] = useState<boolean>(false);
  const [isDecrypting, setIsDecrypting] = useState<boolean>(false);
  const [isAddingMessage, setIsAddingMessage] = useState<boolean>(false);
  const [message, setMessage] = useState<string>("");

  // 本地映射表：存储句柄到原始文本的映射（仅在用户会话期间存在）
  const plaintextMapRef = useRef<Map<string, {title: string, content: string, tempHandles?: any[]}>>(new Map());

  const messageBoardRef = useRef<MessageBoardInfoType | undefined>(undefined);
  const isRefreshingRef = useRef<boolean>(isRefreshing);
  const isDecryptingRef = useRef<boolean>(isDecrypting);
  const isAddingMessageRef = useRef<boolean>(isAddingMessage);

  //////////////////////////////////////////////////////////////////////////////
  // MessageBoard
  //////////////////////////////////////////////////////////////////////////////

  const messageBoard = useMemo(() => {
    const c = getMessageBoardByChainId(chainId);

    messageBoardRef.current = c;

    if (!c.address) {
      setMessage(`MessageBoard deployment not found for chainId=${chainId}.`);
    }

    return c;
  }, [chainId]);

  //////////////////////////////////////////////////////////////////////////////
  // Contract availability
  //////////////////////////////////////////////////////////////////////////////

  const isDeployed = useMemo(() => {
    if (!messageBoard) {
      return undefined;
    }
    return (Boolean(messageBoard.address) && messageBoard.address !== ethers.ZeroAddress);
  }, [messageBoard]);

  const canGetMessages = useMemo(() => {
    return messageBoard.address && ethersReadonlyProvider && !isRefreshing;
  }, [messageBoard.address, ethersReadonlyProvider, isRefreshing]);

  const canAddMessage = useMemo(() => {
    return messageBoard.address && instance && ethersSigner && !isRefreshing && !isAddingMessage;
  }, [messageBoard.address, instance, ethersSigner, isRefreshing, isAddingMessage]);

  const canDecryptMessage = useMemo(() => {
    return messageBoard.address && instance && ethersSigner && !isRefreshing && !isDecrypting;
  }, [messageBoard.address, instance, ethersSigner, isRefreshing, isDecrypting]);

  //////////////////////////////////////////////////////////////////////////////
  // Load Messages
  //////////////////////////////////////////////////////////////////////////////

  const refreshMessages = useCallback(() => {
    console.log("[useMessageBoard] call refreshMessages()");
    if (isRefreshingRef.current) {
      return;
    }

    if (
      !messageBoardRef.current ||
      !messageBoardRef.current?.chainId ||
      !messageBoardRef.current?.address ||
      !ethersReadonlyProvider
    ) {
      setMessages([]);
      return;
    }

    isRefreshingRef.current = true;
    setIsRefreshing(true);
    setMessage("Loading messages...");

    const thisChainId = messageBoardRef.current.chainId;
    const thisMessageBoardAddress = messageBoardRef.current.address;

    const thisMessageBoardContract = new ethers.Contract(
      thisMessageBoardAddress,
      messageBoardRef.current.abi,
      ethersReadonlyProvider
    );

    const loadMessages = async () => {
      try {
        // Get message count
        const messageCount = await thisMessageBoardContract.getMessageCount();
        console.log("[useMessageBoard] getMessageCount()=" + messageCount);

        if (!sameChain.current(thisChainId) ||
            thisMessageBoardAddress !== messageBoardRef.current?.address) {
          return;
        }

        // Get all message IDs
        const messageIds = await thisMessageBoardContract.getAllMessageIds();
        console.log("[useMessageBoard] messageIds=" + messageIds);

        if (!sameChain.current(thisChainId) ||
            thisMessageBoardAddress !== messageBoardRef.current?.address) {
          return;
        }

        const messagePromises = [];
        for (let i = 0; i < messageIds.length; i++) {
          const messageId = Number(messageIds[i]);
          // Get message metadata (non-encrypted data)
          const metadataPromise = thisMessageBoardContract.getMessageMetadata(messageId);
          messagePromises.push(
            metadataPromise.then(async (metadata) => {
              const [author, timestamp, exists] = metadata;
              if (!exists) return null;

              return {
                id: messageId,
                author,
                timestamp: Number(timestamp),
                title: undefined,
                content: undefined,
                isDecrypted: false,
              } as MessageType;
            })
          );
        }

        const loadedMessages = (await Promise.all(messagePromises)).filter(m => m !== null) as MessageType[];
        loadedMessages.sort((a, b) => b.timestamp - a.timestamp); // Newest first

        if (sameChain.current(thisChainId) &&
            thisMessageBoardAddress === messageBoardRef.current?.address) {
          setMessages(loadedMessages);
          setMessage(`Loaded ${loadedMessages.length} messages`);
        }
      } catch (error) {
        setMessage("Failed to load messages: " + error);
      } finally {
        isRefreshingRef.current = false;
        setIsRefreshing(false);
      }
    };

    loadMessages();
  }, [ethersReadonlyProvider, sameChain]);

  // Auto refresh messages
  useEffect(() => {
    refreshMessages();
  }, [refreshMessages]);

  //////////////////////////////////////////////////////////////////////////////
  // Add Message
  //////////////////////////////////////////////////////////////////////////////

  const addMessage = useCallback(
    (title: string, content: string) => {
      console.log('addMessage called with:', { title, content });

      if (isRefreshingRef.current || isAddingMessageRef.current) {
        console.log('addMessage blocked: refreshing or adding in progress');
        return;
      }

      if (!messageBoard.address || !instance || !ethersSigner) {
        return;
      }

      const thisChainId = chainId;
      const thisMessageBoardAddress = messageBoard.address;
      const thisEthersSigner = ethersSigner;

      const thisMessageBoardContract = new ethers.Contract(
        thisMessageBoardAddress,
        messageBoard.abi,
        thisEthersSigner
      );

      const opMsg = `Add message: ${title}`;

      isAddingMessageRef.current = true;
      setIsAddingMessage(true);
      setMessage(`Starting ${opMsg}...`);

      const run = async (title: string, content: string) => {
        // let the browser repaint before running 'input.encrypt()' (CPU-costly)
        await new Promise((resolve) => setTimeout(resolve, 100));

        const isStale = () =>
          thisMessageBoardAddress !== messageBoardRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          // Create encrypted inputs
          const titleInput = instance.createEncryptedInput(
            thisMessageBoardAddress,
            thisEthersSigner.address
          );
          // For demo purposes, convert string to a simple hash/number (fit in 32 bits)
          const titleHash = title.split('').reduce((a, b) => a + b.charCodeAt(0), 0) % (2**32 - 1);
          titleInput.add32(titleHash);

          const contentInput = instance.createEncryptedInput(
            thisMessageBoardAddress,
            thisEthersSigner.address
          );
          // For demo purposes, convert string to a simple hash/number (fit in 32 bits)
          const contentHash = content.split('').reduce((a, b) => a + b.charCodeAt(0), 0) % (2**32 - 1);
          contentInput.add32(contentHash);

          // Encrypt (CPU-intensive)
          const titleEnc = await titleInput.encrypt();
          const contentEnc = await contentInput.encrypt();

          if (isStale()) {
            setMessage(`Cancelled ${opMsg}`);
            return;
          }

          // 暂时用一个临时key存储原始文本，待交易成功后用真实的handle更新
          const tempKey = `temp_${Date.now()}_${Math.random()}`;
          plaintextMapRef.current.set(tempKey, { title, content, tempHandles: [titleEnc.handles[0], contentEnc.handles[0]] });
          console.log('Stored temporary mapping:', { tempKey, title, content, tempHandles: [titleEnc.handles[0], contentEnc.handles[0]] });

          setMessage(`Sending ${opMsg}...`);

          // Call contract
          const tx: ethers.TransactionResponse = await thisMessageBoardContract.addMessage(
            titleEnc.handles[0],
            titleEnc.inputProof,
            contentEnc.handles[0],
            contentEnc.inputProof
          );

          setMessage(`Waiting for tx:${tx.hash}...`);

          const receipt = await tx.wait();

          setMessage(`${opMsg} completed status=${receipt?.status}`);

          if (isStale()) {
            setMessage(`Cancelled ${opMsg}`);
            return;
          }

          // 交易成功后，从合约获取真实的handle并更新映射
          try {
            const messageCount = await thisMessageBoardContract.getMessageCount();
            const newMessageId = Number(messageCount);

            const realTitleHandle = await thisMessageBoardContract.getMessageTitle(newMessageId);
            const realContentHandle = await thisMessageBoardContract.getMessageContent(newMessageId);

            const realTitleHandleKey = ethers.hexlify(realTitleHandle);
            const realContentHandleKey = ethers.hexlify(realContentHandle);
            const realMapKey = `${realTitleHandleKey}_${realContentHandleKey}`;

            // 从临时映射中找到对应的原始文本
            let originalText = null;
            for (const [key, value] of plaintextMapRef.current.entries()) {
              if (key.startsWith('temp_') && value.tempHandles) {
                // 找到匹配的临时条目
                originalText = { title: value.title, content: value.content };
                plaintextMapRef.current.delete(key); // 删除临时条目
                break;
              }
            }

            if (originalText) {
              plaintextMapRef.current.set(realMapKey, originalText);
              console.log('Updated mapping with real handles:', { realMapKey, ...originalText });
            }
          } catch (error) {
            console.error('Failed to update mapping with real handles:', error);
          }

          await refreshMessages();
        } catch (error) {
          setMessage(`${opMsg} Failed: ${error}`);
        } finally {
          isAddingMessageRef.current = false;
          setIsAddingMessage(false);
        }
      };

      run(title, content);
    },
    [
      ethersSigner,
      messageBoard.address,
      messageBoard.abi,
      instance,
      chainId,
      refreshMessages,
      sameChain,
      sameSigner,
    ]
  );

  //////////////////////////////////////////////////////////////////////////////
  // Decrypt Message
  //////////////////////////////////////////////////////////////////////////////

  const decryptMessage = useCallback(
    async (messageId: number) => {
      if (isRefreshingRef.current || isDecryptingRef.current) {
        return;
      }

      if (!messageBoard.address || !instance || !ethersSigner || !ethersReadonlyProvider) {
        return;
      }

      const thisChainId = chainId;
      const thisMessageBoardAddress = messageBoard.address;
      const thisEthersSigner = ethersSigner;

      setIsDecrypting(true);
      isDecryptingRef.current = true;
      setMessage(`Decrypting message ${messageId}...`);

      const isStale = () =>
        thisMessageBoardAddress !== messageBoardRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        // Get the encrypted handles from the contract
        const contract = new ethers.Contract(
          thisMessageBoardAddress,
          messageBoard.abi,
          ethersReadonlyProvider
        );

        const titleHandle = await contract.getMessageTitle(messageId);
        const contentHandle = await contract.getMessageContent(messageId);

        if (isStale()) {
          setMessage("Decryption cancelled");
          return;
        }

        // 从本地映射表中查找原始文本
        const titleHandleStr = ethers.hexlify(titleHandle);
        const contentHandleStr = ethers.hexlify(contentHandle);
        const mapKey = `${titleHandleStr}_${contentHandleStr}`;

        console.log('Looking up mapping:', { mapKey, titleHandleStr, contentHandleStr });
        console.log('All stored mappings:', Array.from(plaintextMapRef.current.entries()).map(([key, value]) => ({
          key,
          title: value.title,
          content: value.content,
          hasTempHandles: !!value.tempHandles
        })));

        const originalText = plaintextMapRef.current.get(mapKey);

        if (originalText) {
          // 成功找到原始文本
          setMessages(prevMessages =>
            prevMessages.map(msg =>
              msg.id === messageId
                ? {
                    ...msg,
                    isDecrypted: true,
                    title: `Title: "${originalText.title}"`,
                    content: `Content: "${originalText.content}"`
                  }
                : msg
            )
          );
          setMessage(`Message ${messageId} decrypted successfully!`);
        } else {
          // 未找到映射，显示加密句柄信息
          const titleHandleHex = titleHandle.toString(16).padStart(8, '0');
          const contentHandleHex = contentHandle.toString(16).padStart(8, '0');

          setMessages(prevMessages =>
            prevMessages.map(msg =>
              msg.id === messageId
                ? {
                    ...msg,
                    isDecrypted: true,
                    title: `Title Handle: ${titleHandleHex.slice(-8)} (original text not found)`,
                    content: `Content Handle: ${contentHandleHex.slice(-8)} (original text not found)`
                  }
                : msg
            )
          );
          setMessage(`Message ${messageId}: Original text mapping not found (possibly from another session)`);
        }

      } catch (error) {
        setMessage(`Decryption failed: ${error}`);
      } finally {
        setIsDecrypting(false);
        isDecryptingRef.current = false;
      }
    },
    [
      fhevmDecryptionSignatureStorage,
      ethersSigner,
      messageBoard.address,
      instance,
      chainId,
      sameChain,
      sameSigner,
    ]
  );

  return {
    contractAddress: messageBoard.address,
    messages,
    canGetMessages,
    canAddMessage,
    canDecryptMessage,
    addMessage,
    decryptMessage,
    refreshMessages,
    message,
    isRefreshing,
    isDecrypting,
    isAddingMessage,
    isDeployed
  };
};
